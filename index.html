<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Responsive Chessboard - Click to Move</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0; padding: 0;
  }
  body {
    font-family: Arial, sans-serif;
    background: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
  }
  h1 {
    margin-bottom: 10px;
  }
  #turnIndicator {
    margin-bottom: 10px;
    font-weight: bold;
    font-size: 1.2em;
  }
  #score {
    margin-bottom: 15px;
    font-size: 1.1em;
  }
  .controls {
    margin-bottom: 15px;
  }
  button {
    font-size: 1em;
    padding: 6px 12px;
    margin: 0 5px;
    cursor: pointer;
  }
  .chessboard {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    width: 90vmin;
    aspect-ratio: 1 / 1;
    border: 4px solid #333;
    user-select: none;
  }
  .square {
    width: 100%;
    aspect-ratio: 1 / 1;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 5vmin;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  .light {
    background-color: #f0d9b5;
  }
  .dark {
    background-color: #b58863;
  }
  .selected {
    outline: 3px solid #00f;
    outline-offset: -3px;
  }
  .highlight {
    background-color: #9f9;
  }
  canvas#fireworks {
    position: fixed;
    pointer-events: none;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1000;
  }
</style>
</head>
<body>

<h1>Responsive Chessboard - Click to Move</h1>
<div id="turnIndicator">Turn: White</div>
<div id="score">White: 0 | Black: 0</div>
<div class="controls">
  <button id="resetBtn">Reset</button>
  <button id="flipBtn">Flip Board</button>
</div>

<div class="chessboard" id="board"></div>

<canvas id="fireworks"></canvas>

<script>
(() => {
  const board = document.getElementById('board');
  const turnIndicator = document.getElementById('turnIndicator');
  const scoreDisplay = document.getElementById('score');
  const resetBtn = document.getElementById('resetBtn');
  const flipBtn = document.getElementById('flipBtn');
  const fireworksCanvas = document.getElementById('fireworks');
  const ctx = fireworksCanvas.getContext('2d');

  fireworksCanvas.width = window.innerWidth;
  fireworksCanvas.height = window.innerHeight;

  // Unicode for chess pieces, white and black
  const unicodePieces = {
    'wK': '♔', 'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘', 'wP': '♙',
    'bK': '♚', 'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞', 'bP': '♟'
  };

  // Initial chess board setup (8x8 array)
  const initialSetup = [
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['wP','wP','wP','wP','wP','wP','wP','wP'],
    ['wR','wN','wB','wQ','wK','wB','wN','wR'],
  ];

  let gameState = JSON.parse(JSON.stringify(initialSetup)); // Deep copy
  let turn = 'white';
  let whiteScore = 0;
  let blackScore = 0;
  let flipped = false;
  let gameOver = false;

  let selectedSquare = null; // holds coords {r,c} of selected piece
  let possibleMoves = [];

  // Render the chessboard squares and pieces
  function renderBoard() {
    board.innerHTML = '';
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        const sq = document.createElement('div');
        sq.classList.add('square');
        // Color squares alternating light/dark with flip
        const rr = flipped ? 7 - r : r;
        const cc = flipped ? 7 - c : c;
        const isLight = (rr + cc) % 2 === 0;
        sq.classList.add(isLight ? 'light' : 'dark');

        sq.dataset.row = r;
        sq.dataset.col = c;

        // Add piece if any
        const piece = gameState[r][c];
        if(piece) {
          sq.textContent = unicodePieces[piece];
          sq.style.color = piece[0] === 'w' ? '#eee' : '#222';
        } else {
          sq.textContent = '';
        }

        // Highlight selected square
        if(selectedSquare && selectedSquare.r === r && selectedSquare.c === c) {
          sq.classList.add('selected');
        }
        // Highlight possible moves
        if(possibleMoves.some(m => m.r === r && m.c === c)) {
          sq.classList.add('highlight');
        }

        sq.addEventListener('click', onSquareClick);

        board.appendChild(sq);
      }
    }
    turnIndicator.textContent = `Turn: ${turn.charAt(0).toUpperCase() + turn.slice(1)}`;
    scoreDisplay.textContent = `White: ${whiteScore} | Black: ${blackScore}`;
  }

  // On square click: select piece or move selected piece
  function onSquareClick(e) {
    if(gameOver) return;

    const r = parseInt(e.currentTarget.dataset.row);
    const c = parseInt(e.currentTarget.dataset.col);
    const clickedPiece = gameState[r][c];

    if(selectedSquare) {
      // Try move if clicked square is in possible moves
      if(possibleMoves.some(m => m.r === r && m.c === c)) {
        makeMove(selectedSquare.r, selectedSquare.c, r, c);
        selectedSquare = null;
        possibleMoves = [];
        renderBoard();
      } else {
        // Select new piece if clicked on own piece
        if(clickedPiece && clickedPiece[0] === turn[0]) {
          selectedSquare = {r,c};
          possibleMoves = getValidMoves(r, c);
          renderBoard();
        } else {
          // Deselect if invalid
          selectedSquare = null;
          possibleMoves = [];
          renderBoard();
        }
      }
    } else {
      // No selection yet, select piece if it's player's turn
      if(clickedPiece && clickedPiece[0] === turn[0]) {
        selectedSquare = {r,c};
        possibleMoves = getValidMoves(r, c);
        renderBoard();
      }
    }
  }

  // Move a piece if valid
  function makeMove(fromR, fromC, toR, toC) {
    const movingPiece = gameState[fromR][fromC];
    if(!movingPiece) return false;

    // Capture check
    const capturedPiece = gameState[toR][toC];
    const opponent = turn === 'white' ? 'black' : 'white';

    // Move piece
    gameState[toR][toC] = movingPiece;
    gameState[fromR][fromC] = '';

    // Update scores if captured piece
    if(capturedPiece) {
      if(capturedPiece[1] === 'K') {
        // King captured, game over
        gameOver = true;
        startFireworks();
        setTimeout(() => alert(`${turn.charAt(0).toUpperCase() + turn.slice(1)} wins!`), 100);
      } else {
        if(turn === 'white') whiteScore++;
        else blackScore++;
      }
    }

    if(!gameOver) {
      // Switch turns
      turn = opponent;
      turnIndicator.textContent = `Turn: ${turn.charAt(0).toUpperCase() + turn.slice(1)}`;
    }
    return true;
  }

  // Return array of valid moves {r,c} for piece at (r,c)
  function getValidMoves(r, c) {
    const piece = gameState[r][c];
    if(!piece) return [];
    const color = piece[0];
    const type = piece[1];
    const opponent = color === 'w' ? 'b' : 'w';
    let moves = [];

    function onBoard(rr, cc) {
      return rr >=0 && rr <8 && cc >=0 && cc <8;
    }

    // Helper to add moves in line directions for sliding pieces (R, B, Q)
    function addLineMoves(drs, dcs) {
      for(let i=0; i<drs.length; i++) {
        let dr = drs[i];
        let dc = dcs[i];
        let rr = r + dr;
        let cc = c + dc;
        while(onBoard(rr,cc)) {
          if(gameState[rr][cc] === '') {
            moves.push({r: rr, c: cc});
          } else {
            if(gameState[rr][cc][0] === opponent) {
              moves.push({r: rr, c: cc});
            }
            break;
          }
          rr += dr;
          cc += dc;
        }
      }
    }

    switch(type) {
      case 'P': { // Pawn
        const forward = color === 'w' ? -1 : 1;
        // Move forward 1
        if(onBoard(r+forward,c) && gameState[r+forward][c] === '') {
          moves.push({r: r+forward, c: c});
          // Move forward 2 on starting pos
          if((color === 'w' && r === 6) || (color === 'b' && r ===1)) {
            if(gameState[r+2*forward][c] === '') {
              moves.push({r: r+2*forward, c: c});
            }
          }
        }
        // Capture diagonals
        for(let dc of [-1,1]) {
          let rr = r+forward, cc = c+dc;
          if(onBoard(rr,cc) && gameState[rr][cc] !== '' && gameState[rr][cc][0] === opponent) {
            moves.push({r: rr, c: cc});
          }
        }
        break;
      }
      case 'R': { // Rook
        addLineMoves([1,-1,0,0], [0,0,1,-1]);
        break;
      }
      case 'N': { // Knight
        const knightMoves = [
          [r+2, c+1],[r+2, c-1],[r-2, c+1],[r-2, c-1],
          [r+1, c+2],[r+1, c-2],[r-1, c+2],[r-1, c-2],
        ];
        for(let [rr,cc] of knightMoves) {
          if(onBoard(rr,cc) && (gameState[rr][cc] === '' || gameState[rr][cc][0] === opponent)) {
            moves.push({r: rr, c: cc});
          }
        }
        break;
      }
      case 'B': { // Bishop
        addLineMoves([1,1,-1,-1], [1,-1,1,-1]);
        break;
      }
      case 'Q': { // Queen (Rook + Bishop)
        addLineMoves([1,-1,0,0,1,1,-1,-1], [0,0,1,-1,1,-1,1,-1]);
        break;
      }
      case 'K': { // King
        for(let dr=-1; dr<=1; dr++) {
          for(let dc=-1; dc<=1; dc++) {
            if(dr ===0 && dc===0) continue;
            let rr = r+dr, cc = c+dc;
            if(onBoard(rr,cc) && (gameState[rr][cc] === '' || gameState[rr][cc][0] === opponent)) {
              moves.push({r: rr, c: cc});
            }
          }
        }
        break;
      }
    }

    // For this basic demo: no check detection or castling yet
    return moves;
  }

  // Reset game state
  function resetGame() {
    gameState = JSON.parse(JSON.stringify(initialSetup));
    turn = 'white';
    whiteScore = 0;
    blackScore = 0;
    gameOver = false;
    selectedSquare = null;
    possibleMoves = [];
    renderBoard();
    stopFireworks();
  }

  // Flip board view
  function flipBoard() {
    flipped = !flipped;
    renderBoard();
  }

  // Fireworks celebration (simple particles)
  let fireworks = [];
  let animationFrameId;

  function startFireworks() {
    fireworks = [];
    for(let i=0; i<100; i++) {
      fireworks.push({
        x: Math.random()*fireworksCanvas.width,
        y: Math.random()*fireworksCanvas.height*0.5,
        radius: Math.random()*3+2,
        color: `hsl(${Math.random()*360}, 100%, 50%)`,
        dx: (Math.random()-0.5)*5,
        dy: (Math.random()-0.5)*5,
        life: 100 + Math.random()*100,
      });
    }
    animateFireworks();
  }

  function animateFireworks() {
    ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
    fireworks.forEach((f, i) => {
      ctx.beginPath();
      ctx.fillStyle = f.color;
      ctx.shadowColor = f.color;
      ctx.shadowBlur = 10;
      ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
      ctx.fill();

      f.x += f.dx;
      f.y += f.dy;
      f.life--;
      if(f.life <= 0) {
        fireworks.splice(i, 1);
      }
    });
    if(fireworks.length > 0) {
      animationFrameId = requestAnimationFrame(animateFireworks);
    }
  }

  function stopFireworks() {
    if(animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
      ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
    }
  }

  // Initialize
  resetBtn.onclick = resetGame;
  flipBtn.onclick = flipBoard;
  renderBoard();

  // Handle window resize for fireworks canvas
  window.addEventListener('resize', () => {
    fireworksCanvas.width = window.innerWidth;
    fireworksCanvas.height = window.innerHeight;
  });
})();
</script>

</body>
</html>
