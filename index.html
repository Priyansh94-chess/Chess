<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Full Chess Program</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: Arial, sans-serif;
    background: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
  }
  h1 { margin-bottom: 10px; }
  #turnIndicator {
    margin-bottom: 10px;
    font-weight: bold;
    font-size: 1.2em;
  }
  #score {
    margin-bottom: 15px;
    font-size: 1.1em;
  }
  .controls {
    margin-bottom: 15px;
  }
  button {
    font-size: 1em;
    padding: 6px 12px;
    margin: 0 5px;
    cursor: pointer;
  }
  .chessboard {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    width: 90vmin;
    aspect-ratio: 1 / 1;
    border: 4px solid #333;
    user-select: none;
  }
  .square {
    width: 100%;
    aspect-ratio: 1 / 1;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 5vmin;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  .light { background-color: #f0d9b5; }
  .dark { background-color: #b58863; }
  .selected { outline: 3px solid #00f; outline-offset: -3px; }
  .highlight { background-color: #9f9; }
  canvas#fireworks {
    position: fixed;
    pointer-events: none;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1000;
  }
</style>
</head>
<body>

<h1>Full Chess Program</h1>
<div id="turnIndicator">Turn: White</div>
<div id="score">White: 0 | Black: 0</div>
<div class="controls">
  <button id="resetBtn">Reset</button>
  <button id="flipBtn">Flip Board</button>
</div>

<div class="chessboard" id="board"></div>

<canvas id="fireworks"></canvas>

<script>
(() => {
  const board = document.getElementById('board');
  const turnIndicator = document.getElementById('turnIndicator');
  const scoreDisplay = document.getElementById('score');
  const resetBtn = document.getElementById('resetBtn');
  const flipBtn = document.getElementById('flipBtn');
  const fireworksCanvas = document.getElementById('fireworks');
  const ctx = fireworksCanvas.getContext('2d');

  fireworksCanvas.width = window.innerWidth;
  fireworksCanvas.height = window.innerHeight;

  const unicodePieces = {
    'wK': '♔', 'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘', 'wP': '♙',
    'bK': '♚', 'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞', 'bP': '♟'
  };

  const initialSetup = [
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['wP','wP','wP','wP','wP','wP','wP','wP'],
    ['wR','wN','wB','wQ','wK','wB','wN','wR'],
  ];

  let gameState = JSON.parse(JSON.stringify(initialSetup)); // deep copy
  let turn = 'white';
  let whiteScore = 0;
  let blackScore = 0;
  let flipped = false;
  let gameOver = false;
  let selectedSquare = null;
  let possibleMoves = [];

  // Track if each side has moved a pawn yet (for first move rule)
  let pawnMoved = { white: false, black: false };

  // Utility: copy gameState (deep)
  function copyGameState(state) {
    return state.map(row => row.slice());
  }

  // Find king position for a color
  function findKing(state, color) {
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(state[r][c] === (color === 'white' ? 'wK' : 'bK')) return {r, c};
      }
    }
    return null;
  }

  // Check if position on board
  function onBoard(r,c) {
    return r >= 0 && r < 8 && c >= 0 && c < 8;
  }

  // Check if a square is attacked by opponent (used for check detection)
  function isSquareAttacked(state, r, c, attackerColor) {
    // We simulate possible moves for each enemy piece to see if it attacks r,c
    const opponent = attackerColor;
    // For each piece of opponentColor, check if it can move to r,c ignoring check
    for(let rr=0; rr<8; rr++) {
      for(let cc=0; cc<8; cc++) {
        const piece = state[rr][cc];
        if(piece && piece[0] === (opponent === 'white' ? 'w' : 'b')) {
          const moves = getPseudoLegalMoves(state, rr, cc, true);
          if(moves.some(m => m.r === r && m.c === c)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  // Get pseudo-legal moves (ignores check)
  function getPseudoLegalMoves(state, r, c, forAttack=false) {
    const piece = state[r][c];
    if(!piece) return [];
    const color = piece[0];
    const type = piece[1];
    const opponent = color === 'w' ? 'b' : 'w';
    let moves = [];

    function addLineMoves(drs, dcs) {
      for(let i=0; i<drs.length; i++) {
        let dr = drs[i];
        let dc = dcs[i];
        let rr = r + dr;
        let cc = c + dc;
        while(onBoard(rr,cc)) {
          if(state[rr][cc] === '') {
            moves.push({r: rr, c: cc});
          } else {
            if(state[rr][cc][0] === opponent) {
              moves.push({r: rr, c: cc});
            }
            break;
          }
          rr += dr;
          cc += dc;
        }
      }
    }

    switch(type) {
      case 'P': {
        const forward = color === 'w' ? -1 : 1;
        // Move forward 1 (only if not attacking)
        if(!forAttack && onBoard(r+forward, c) && state[r+forward][c] === '') {
          moves.push({r: r+forward, c: c});
          // Move forward 2 if on start rank and no blocking piece
          if((color === 'w' && r === 6) || (color === 'b' && r === 1)) {
            if(state[r+2*forward][c] === '') {
              moves.push({r: r+2*forward, c: c});
            }
          }
        }
        // Capture diagonals
        for(let dc of [-1,1]) {
          let rr = r+forward, cc = c+dc;
          if(onBoard(rr, cc) && state[rr][cc] !== '' && state[rr][cc][0] === opponent) {
            moves.push({r: rr, c: cc});
          }
          // For attack check, pawns attack diagonals regardless of occupancy
          if(forAttack && onBoard(rr, cc)) {
            moves.push({r: rr, c: cc});
          }
        }
        break;
      }
      case 'R': {
        addLineMoves([1,-1,0,0], [0,0,1,-1]);
        break;
      }
      case 'N': {
        const knightMoves = [
          [r+2, c+1],[r+2, c-1],[r-2, c+1],[r-2, c-1],
          [r+1, c+2],[r+1, c-2],[r-1, c+2],[r-1, c-2],
        ];
        for(let [rr, cc] of knightMoves) {
          if(onBoard(rr, cc) && (state[rr][cc] === '' || state[rr][cc][0] !== color)) {
            moves.push({r: rr, c: cc});
          }
        }
        break;
      }
      case 'B': {
        addLineMoves([1,1,-1,-1], [1,-1,1,-1]);
        break;
      }
      case 'Q': {
        addLineMoves([1,-1,0,0,1,1,-1,-1], [0,0,1,-1,1,-1,1,-1]);
        break;
      }
      case 'K': {
        const kingMoves = [
          [r+1,c],[r-1,c],[r,c+1],[r,c-1],[r+1,c+1],[r+1,c-1],[r-1,c+1],[r-1,c-1]
        ];
        for(let [rr,cc] of kingMoves) {
          if(onBoard(rr, cc) && (state[rr][cc] === '' || state[rr][cc][0] !== color)) {
            moves.push({r: rr, c: cc});
          }
        }
        break;
      }
    }
    return moves;
  }

  // Get legal moves (checks that move doesn't leave king in check)
  function getLegalMoves(state, r, c) {
    const piece = state[r][c];
    if(!piece) return [];
    const color = piece[0] === 'w' ? 'white' : 'black';

    let pseudoMoves = getPseudoLegalMoves(state, r, c);

    let legalMoves = [];
    for(let move of pseudoMoves) {
      let testState = copyGameState(state);
      // Move piece
      testState[move.r][move.c] = piece;
      testState[r][c] = '';

      // Find king pos after move (if king moved)
      let kingPos = findKing(testState, color);
      if(!kingPos) continue; // Should never happen, king always present

      // Is king attacked?
      if(!isSquareAttacked(testState, kingPos.r, kingPos.c, color === 'white' ? 'black' : 'white')) {
        legalMoves.push(move);
      }
    }
    return legalMoves;
  }

  // Pawn first move rule: only pawns can move first move for each side
  // We enforce this by disallowing any move except pawn moves if that side hasn't moved pawn yet.
  function filterByPawnFirstMove(moves, r, c, color) {
    if(pawnMoved[color]) return moves;
    const piece = gameState[r][c];
    if(!piece) return [];
    if(piece[1] !== 'P') return []; // Only pawns allowed if pawnMoved false
    return moves;
  }

  // Draw board
  function drawBoard() {
    board.innerHTML = '';
    // Show ranks/files labels if needed (not asked but easy)
    const squares = [];
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        let rr = flipped ? 7-r : r;
        let cc = flipped ? 7-c : c;
        const sq = document.createElement('div');
        sq.classList.add('square');
        if((rr + cc) % 2 === 0) sq.classList.add('light');
        else sq.classList.add('dark');
        sq.dataset.r = rr;
        sq.dataset.c = cc;
        const piece = gameState[rr][cc];
        sq.textContent = piece ? unicodePieces[piece] : '';
        squares.push(sq);
      }
    }
    squares.forEach(sq => board.appendChild(sq));
  }

  // Update UI: turn text and score
  function updateUI() {
    turnIndicator.textContent = `Turn: ${turn[0].toUpperCase() + turn.slice(1)}`;
    scoreDisplay.textContent = `White: ${whiteScore} | Black: ${blackScore}`;
  }

  // Highlight squares
  function highlightSquares(moves) {
    // Remove old highlights and selected
    document.querySelectorAll('.square').forEach(sq => {
      sq.classList.remove('highlight');
      sq.classList.remove('selected');
    });
    if(selectedSquare) {
      const sel = document.querySelector(`.square[data-r="${selectedSquare.r}"][data-c="${selectedSquare.c}"]`);
      if(sel) sel.classList.add('selected');
    }
    moves.forEach(m => {
      const sq = document.querySelector(`.square[data-r="${m.r}"][data-c="${m.c}"]`);
      if(sq) sq.classList.add('highlight');
    });
  }

  // Check for check or checkmate after move
  function checkCheckAndMate() {
    // Is opponent in check?
    const opponent = turn === 'white' ? 'black' : 'white';
    const kingPos = findKing(gameState, opponent);
    if(!kingPos) return {check: false, checkmate: false};

    const inCheck = isSquareAttacked(gameState, kingPos.r, kingPos.c, turn);
    if(!inCheck) return {check: false, checkmate: false};

    // Checkmate if opponent has no legal moves
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        const piece = gameState[r][c];
        if(piece && (piece[0] === (opponent === 'white' ? 'w' : 'b'))) {
          let moves = getLegalMoves(gameState, r, c);
          if(moves.length > 0) {
            return {check: true, checkmate: false};
          }
        }
      }
    }
    return {check: true, checkmate: true};
  }

  // Fireworks animation on checkmate
  // Adapted from https://codepen.io/anon/pen/QxbYbm with simplification
  let fireworks = [];
  let gravity = 0.2;

  class Firework {
    constructor() {
      this.x = Math.random() * fireworksCanvas.width;
      this.y = fireworksCanvas.height;
      this.sparks = [];
      this.exploded = false;
      this.color = `hsl(${Math.random()*360}, 100%, 50%)`;
      this.speedY = Math.random() * 7 + 10;
    }
    update() {
      if(!this.exploded) {
        this.y -= this.speedY;
        this.speedY -= gravity;
        if(this.speedY <= 0) {
          this.explode();
        }
      } else {
        this.sparks.forEach(s => s.update());
        this.sparks = this.sparks.filter(s => s.alpha > 0);
      }
    }
    explode() {
      this.exploded = true;
      const count = 30;
      for(let i=0; i<count; i++) {
        const angle = (Math.PI*2 / count) * i;
        const speed = Math.random() * 4 + 1;
        this.sparks.push(new Spark(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, this.color));
      }
    }
    draw() {
      if(!this.exploded) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
        ctx.fillStyle = this.color;
        ctx.fill();
      } else {
        this.sparks.forEach(s => s.draw());
      }
    }
    isDone() {
      return this.exploded && this.sparks.length === 0;
    }
  }

  class Spark {
    constructor(x,y,vx,vy,color) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.color = color;
      this.alpha = 1;
      this.size = 2;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.vy += gravity/2;
      this.alpha -= 0.02;
    }
    draw() {
      ctx.save();
      ctx.globalAlpha = this.alpha;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function animateFireworks() {
    ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
    fireworks.forEach(fw => {
      fw.update();
      fw.draw();
    });
    fireworks = fireworks.filter(fw => !fw.isDone());
    if(fireworks.length > 0) {
      requestAnimationFrame(animateFireworks);
    }
  }

  function launchFireworks() {
    for(let i=0; i<5; i++) {
      fireworks.push(new Firework());
    }
    animateFireworks();
  }

  // Move piece if legal
  function tryMove(from, to) {
    if(gameOver) return;

    const piece = gameState[from.r][from.c];
    if(!piece) return;

    const color = piece[0] === 'w' ? 'white' : 'black';
    if(color !== turn) return;

    // Get legal moves and filter by pawn first move rule
    let legalMoves = getLegalMoves(gameState, from.r, from.c);
    legalMoves = filterByPawnFirstMove(legalMoves, from.r, from.c, color);

    if(!legalMoves.some(m => m.r === to.r && m.c === to.c)) return;

    // Move piece
    let capturedPiece = gameState[to.r][to.c];
    gameState[to.r][to.c] = piece;
    gameState[from.r][from.c] = '';

    // Update pawnMoved flag if pawn moved
    if(piece[1] === 'P' && !pawnMoved[color]) pawnMoved[color] = true;

    // Update scores on capture
    if(capturedPiece) {
      if(capturedPiece[0] === 'w') {
        whiteScore++;
      } else {
        blackScore++;
      }
    }

    // Check check or mate on opponent
    let {check, checkmate} = checkCheckAndMate();

    drawBoard();
    updateUI();

    // If checkmate, end game with celebration
    if(checkmate) {
      gameOver = true;
      alert(`${turn.charAt(0).toUpperCase() + turn.slice(1)} wins by checkmate!`);
      launchFireworks();
      return;
    }

    if(check) {
      alert(`${turn.charAt(0).toUpperCase() + turn.slice(1)} put opponent in check!`);
    }

    // Switch turn
    turn = (turn === 'white') ? 'black' : 'white';
    selectedSquare = null;
    possibleMoves = [];
    highlightSquares([]);

  }

  // Click handler
  board.addEventListener('click', e => {
    if(gameOver) return;
    if(!e.target.classList.contains('square')) return;

    const r = +e.target.dataset.r;
    const c = +e.target.dataset.c;
    const piece = gameState[r][c];

    // If nothing selected yet
    if(!selectedSquare) {
      if(!piece) return;
      const color = piece[0] === 'w' ? 'white' : 'black';
      if(color !== turn) return;

      let legalMoves = getLegalMoves(gameState, r, c);
      legalMoves = filterByPawnFirstMove(legalMoves, r, c, color);

      if(legalMoves.length === 0) return;

      selectedSquare = {r,c};
      possibleMoves = legalMoves;
      highlightSquares(possibleMoves);
    } else {
      // Try to move
      if(selectedSquare.r === r && selectedSquare.c === c) {
        // Deselect
        selectedSquare = null;
        possibleMoves = [];
        highlightSquares([]);
        return;
      }
      tryMove(selectedSquare, {r,c});
    }
  });

  resetBtn.addEventListener('click', () => {
    gameState = JSON.parse(JSON.stringify(initialSetup));
    turn = 'white';
    whiteScore = 0;
    blackScore = 0;
    pawnMoved = {white:false, black:false};
    gameOver = false;
    selectedSquare = null;
    possibleMoves = [];
    flipped = false;
    updateUI();
    drawBoard();
    highlightSquares([]);
  });

  flipBtn.addEventListener('click', () => {
    flipped = !flipped;
    drawBoard();
    highlightSquares(possibleMoves);
  });

  window.addEventListener('resize', () => {
    fireworksCanvas.width = window.innerWidth;
    fireworksCanvas.height = window.innerHeight;
  });

  // Initial draw
  updateUI();
  drawBoard();

})();
</script>

</body>
</html>
